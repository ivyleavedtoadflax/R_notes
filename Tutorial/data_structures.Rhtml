<html>

<head>
<title>Getting Started with R - Data structures</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">

</head>

<body>

<a class="next" href="selecting_data.html">Previous...Selecting data</a>

<br><hr class="ex1"><br>

<h1>Data structures</h1>

<p>You may have noticed that we have already dealt with two of the different types of data structures - or more correctly - 'objects' available in R. We created vectors using the <tt>c()</tt> and <tt>scan()</tt> commands, whilst we most of the data we have imported so far has been in the <tt>dataframe</tt> format.</p>

<p>I'm going to talk a little about the different types here, just to make you aware, but a much better discussion can be found <a href="http://cran.r-project.org/doc/manuals/R-lang.pdf">here</a>.</p>

<h2>Vectors, lists, and matrices</h2>

<h3>Vectors</h3>

<p>A <tt>vector</tt> can be thought of as a list of contiguous cells, like the first column of a spreadsheet. When we use the methods <tt>c()</tt>, and <tt>scan</tt>, or indeed <tt>seq()</tt>, this is what we will end up with, and when you call a <tt>vector</tt>, you end up with a list of numbers (or other data) displayed horizontally in the console.</p>

<p>Vectors can contain numbers or characters, or booleans (TRUE/FALSE), but they cannot be a mix, they must always contain the same type of data.</p>

<!--begin.rcode,tidy=FALSE
seq(
     from = 1,
     to = 2,
     length.out = 8
     )
end.rcode-->

<h3>Lists</h3>

<p>A <tt>list</tt> can be thought of as a collection of one or more named <tt>vector</tt> of potentially different types. In a list, you can stored many different types of data of different lengths.</p>

<!--begin.rcode,tidy=FALSE
our_list <- list(
     m_names = c("Andrew","Bradley","Charles","Derrick","Edmond","Frank"),
     f_names = c("Georgina","Heidi","Isabelle"),
     age = seq(1,20,1),
     t_f = c(TRUE,FALSE,TRUE,FALSE)
     )

our_list
end.rcode-->

<p>Note that if we only want to call one <tt>vector</tt> from within <tt>our_list</tt>, we must subset it with:</p>

<!--begin.rcode,tidy=FALSE
our_list$m_names
end.rcode-->

<p>Or...</p>

<!--begin.rcode,tidy=FALSE
our_list[1]
end.rcode-->

<p>Lists are useful if you write you own functions, but in practice they are not useful when completing statistical analysis. By the end of this tutorial however, you encounter at least one instance when you need to use a <tt>list</tt>: the <tt>split</tt> function.</p>

<h3>Matrices</h3>

<p>If a <tt>vector</tt> can be thought of as a column in a spreadsheet, a <tt>matrix</tt> can be thought of as one of more columns bound together. A <tt>matrix</tt> is essentially a spreadsheet as we would think about it. Sometimes the best way to view a <tt>matrix</tt> is to use <tt>fix()</tt> or <tt>View()</tt>.</p>

<p>We can make a <tt>matrix</tt> with a call to <tt>matrix()</tt></p>

<!--begin.rcode,tide=FALSE
our_matrix <- matrix(
     ncol = 5,
     nrow = 10
     )

our_matrix
end.rcode-->

<p>Here we created a matrix with 50 columns and ten rows. Again, if we want to select part of the matrix, we need to use subsets <tt>[,]</tt>.</p>

<!--begin.rcode,tide=FALSE
our_matrix[1:2,]
end.rcode-->

<p>And we can populate our matrices in a similar way...</p>

<!--begin.rcode,tide=FALSE
our_matrix[,] <- 1:50

our_matrix
end.rcode-->

<p>Note how the numbers were distributed in the matrix. And, of course, we can subset a smaller part of the matrix:</p>

<!--begin.rcode,tide=FALSE
our_matrix[4:7,2:4] <- letters[1:4]

our_matrix
end.rcode-->

<p>Note that in this example the once numeric matrix has been converted to characters (denoted by the " marks), as we have included letters - like a vector, a matrix can only be one thing: number, boolean, character, etc.</p>

<p>Note that it is possible to convert between the data types. We can change a vector into a matrix:</p>

<!--begin.rcode,tide=FALSE
our_vector <- seq(
     1,
     10,
     1
     )

our_vector    

our_vector_matrix <- as.matrix(our_vector)

our_vector_matrix
end.rcode-->

<p>And we can do the opposite operation...</p>

<!--begin.rcode,tide=FALSE
as.vector(our_vector_matrix)
end.rcode-->


<p>This may seem a bit academic...what difference does it really make if your data is a vector or a matrix? Well not a great deal, in truth, but there are occasions when your code will slip up because your data is in the wrong format. Two useful functions to learn are <tt>as.</tt> followed by matrix/vector/list/data.frame, and <tt>is.</tt> followed by the same. The latter is useful to interrogate what an object is without converting it - this comes in very handy when dealing with functions you do not know.</p>

<!--begin.rcode,tide=FALSE
is.data.frame(our_vector_matrix)
is.list(our_vector_matrix)
is.vector(our_vector_matrix)
is.matrix(our_vector_matrix)
end.rcode-->

<h3>Dataframes</h3>

<h2>Long and wide data</h2>

<p>The astute among you may have noticed, that although I have recommended that you save your data in 'long' format, all the datasets loaded from R and elsewhere, so far, have been in 'wide' rather than 'long' format.</p>

<p>What exactly do we mean by the terms 'long' and 'wide'? And why does it really matter. To give you an example, we'll simulate some data to practice on. This data consist

<p>In this example we will create our own dataset by randomly generating values along a uniform distribution. We'll use a soil science example. We simulate data for an experiment in whcih 144 samples of bulk density <tt>bd</tt>, and organic carbon <tt>oc</tt> were collected in 3 replicate <tt>blocks</tt>, 4 <tt>treatments</tt>, and at 6 <tt>depths</tt>.</p>

<!--begin.rcode,tidy=FALSE

set.seed(1337)

# For brevity these commands have been called lazily!



oc_data <- data.frame(
     block = rep(rep(1:3,each=4),length.out=144),
     treatment = rep(rep(LETTERS[1:4],length=24),length.out=144),     
     depth = rep(1:6,each=24),
     oc = rev(sort(abs(c(5,3,2.2,1.8,1.2,1)+runif(144,max=1.5,min=1.5)+rexp(144,rate=10)))),
     bd = sort(runif(144,min=0.85,max=1.6))
     )

head(oc_data)
str(oc_data)


end.rcode-->

<p>This makes for a reasonably complicated factorial experiment. If we want to get somethign sensible from it, we need to convert it to long format first. We use the package <tt>reshape</tt> to do this...</p>

<!--begin.rcode,warning=FALSE,message=FALSE
library(reshape)
end.rcode-->


<!--begin.rcode,tidy=FALSE,message=FALSE,warning=FALSE,

oc_data_m <- melt(
     oc_data,
     id.vars = 1:3,
     measure.vars = 4:5
     )

head(oc_data_m)

# I won't run this command for brevity, but you should, just to check the data:

#oc_data_m


end.rcode-->

<p>Suppose we want to see the average <tt>bd</tt> and <tt>oc</tt> for each treatment, each depth, and a combination of treatment and depth...</p>

<!--begin.rcode,tidy=FALSE,message=FALSE,warning=FALSE

cast(
     oc_data_m,
     treatment ~ variable,
     mean
     )


# If we want the standard deviation as well as the mean, we can use:

cast(
     oc_data_m,
     depth ~ variable,
     c(mean, sd)
     )

# We can even apply our own custom functions - for example the upper and lower 
# 95% confidence interval

uci95 <- function(x) {
     
     mean(x) + qt(0.975,df = length(x)-1) * sd(x) / sqrt(length(x))

}

lci95 <- function(x) {
     
     mean(x) - qt(0.975,df = length(x)-1) * sd(x) / sqrt(length(x))

}

# and if we are only interested in one variable, and teh top three depths for
# instance...., we subset the data

cast(
     subset(
          oc_data_m, 
          variable == "oc" & depth < 4),
     treatment + depth ~ variable,
     c(mean, sd, lci95, uci95)
     )


end.rcode-->

<p>It's good practice to start using long data early in your <tt>R</tt> career, as many of the more powerful visuliation and analysis packages require it. With the excellent <tt>ggplot</tt> package, for instance, it is possible to produce complex graphics from long data very simply</p>

<!--<!--begin.rcode,"data_structures-1",fig.width=15,tidy=FALSE,fig.height=10

require(ggplot2)

ggplot(
     oc_data_m,
     aes(
          x = factor(depth),
          y = value,
          group = factor(depth),
          fill = variable
          )
     )+#geom_boxplot(fill="gray")+
     geom_jitter(shape=21,size=3.5,alpha=0.5)+
     facet_grid(variable~treatment,scale="free")+
     theme_bw()+xlab("Sampling Depth")

end.rcode-->

<br><hr class="ex1"><br>

<a class="next" href="scatterplots.html">Next...Scatter-plots</a>

</body>

</html>
